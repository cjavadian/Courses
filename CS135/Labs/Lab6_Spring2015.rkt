#lang eopl ;Always remember this line so that DrRacket uses 
;the correct interpreter

; Lab6 assignment Spring 2015     
; Tuesday, March 24, 2015

; Objective: Explore some more Scheme and do some of the things from 
; lecture in Scheme:
; Primes, Prime Factorization, stuff relative (ahem) to that

; Make sure you are using #lang eopl in the first line.
; Read through the rest of this file.  As you go, add the Scheme 
;definitions to your file, one at a time.  Click 'run' for each one, and 
;fix syntax errors before proceeding to the next.  Additional 
;instructions appear in *** comments below. 

; Note: You don't need to type in the comments, but do use menu 
;Scheme/reindent to keep the indentation neat

;Part 0:  Warm Up (Keep & Chuck)
;Part 1:  Euclidean Algorithm
;Part 2:  Sieve of Eratosthenes
;Part 3:  prime?
;Part 4:  Factors and Prime Factorization
;GOLDEN TICKET ????????????????????


;PART 0: Warm Up (Keep & Chuck)

;Let's start with a little recursive practice to shake the rust off.
;Write a recursive program that takes a list of integers and KEEPS the 
;even ones and CHUCKS the odds.

(define (keep-evens list-of-ints)
  "Your definition goes here")

;(keep-evens '()) --> ()
;(keep-evens '(2 4 6)) --> (2 4 6)
;(keep-evens '(1 3 5)) --> ()
;(keep-evens '(1 2 3 4 5 6)) --> (2 4 6)

;HINT (not that you need it): You'll have two recusive calls after your
;"if", one with cons and one without (con cons and sans cons?)  
;Of course, if you use the cond construction, you'll also have two 
;recursive calls, probably one with your last predicate and one with else

;Your TA will NOT ask you about any of this, so you can skip it if you 
;like, but it might be useful at times today.

;Now, if you want to raise the bar, we can do the same thing for ANY 
;predicate.  Write a procedure "filter" that takes a predicate and a list
;as arguments and returns a list of only those items that satisfy the 
;predicate:

(define (filter predicate? list-of-things)
  "Your definition goes here")

;(filter even? '(1 2 3 4 5 6)) --> (2 4 6)  Just like above
;(filter zero? '(0 3 0 2 0 0)) --> (0 0 0 0)
;(filter integer? '(1 2.72 5 0 3.14 1.41 72)) --> (1 5 0 72)

;With Scheme you only need to write the function once since predicates
;and other procedures can be passed as arguments.

;This can even be extended another level up (in a way we might be able 
;to use in PART 2), but it would require that dreaded "lambda" and take 
;a little too much time.  Scheme is really quite powerful and elegant.


;PART 1: Euclidean Algorithm
;
; Let's implement the Euclidean Algorithm to find the Greatest Common 
;Divisor (gcd) of two positive integers, a and d.
;
;Of course, Scheme provides procedures "gcd" and "lcm" which can be
;called on arbitrarily-many arguments:

;(gcd 48 72)
;(lcm 48 72)
;(gcd 20 48 72 144)
;(lcm 20 48 72 144)

;So you might think it isn't worthwhile to spend time on it.
;For now, implement it for 2 parameters to get a feel for how it works,
;and check your work against the built-in "gcd".  Then we'll kick it up
;notch and take a look under the hood.

;Remember:  we use the form  "a = q * d + r" from the division algorithm.
;The q would be (quotient a d) and the r will be (modulo a d)
;We recusively substitute "d" as the new "a" and "r" as the new "d"
;until "r" is zero.  Then the return value is "d".

;An easy recursive procedure:

(define (EuclidAlgo a d)
    ("your definition here"))

; You can find it in several recent lectures and in Rosen.  
;
;  You can check yourself with the built-in (gcd a d) function, but you 
; MUST write your own version that implements the algorithm itself.  
; (It's a quick 4-liner!)  All you need are the (quotient a d) and 
; (modulo a d) functions from Scheme--maybe just one of those!  And a 
; zippy little recursive call.

;So, ours isn't even as good as the built-in version because we've 
;restricted ours to two parameters.  We could try to extand our code to 
;arbitrarily-many argument (easy enough, and fun!), but instead let's
;get a feel for how the argument works by building a list of the 
;remainders generated by the recursive process.  Of course, the last one
;will be the gcd, and we can make a & d the first two.  Then we can watch
;the process crack out the list of remainders:

(define (Euclid-list a d)
  "Your definition goes here")  

;So give that a try.  There's a lot there to play with.
;(Euclid-list 100 100)
;(Euclid-list 100 51)
;(Euclid-list 100 50)
;(Euclid-list 100 49)

;(Euclid-list 72 48)
;(Euclid-list 72 70)
;(Euclid-list 72 68)
;(Euclid-list 72 54)
;(Euclid-list 72 40)

;Here's that question again:  Does it make a difference whether you put
;the larger number in first?  Interesting?

;It's actually quite remarkable how quickly the algorithm works.  The 
;sequence of remainders is always non-negative and strictly decreasing, 
;so we must eventually reach an r that is zero.  And you can see that in
;your lists.

;But how long CAN you make the process take?  Have you found any input
;pairs that seem to take a (relatively) long time?

;(Euclid-list 55 35)
;(Euclid-list 55 34)
;(Euclid-list 55 33)
;(Euclid-list 55 32)

;Aside:  Remember a while back I said we'd use "modulo" rather than "remainder" even though "remainder" has a more familiar ring?  Well, now you know why.  The division algorithm, the foundation on which we're going to build numerous ideas (theorems), requires that our "remainders" live in the range 0 <= r < m.  The Scheme procedure "modulo" guarantees this, but "remainder" can return negatives if we use a negative dividend:

(modulo 33 12)
(remainder 33 12)
(modulo -33 12)
(remainder -33 12)
;Are those last two values related?

;Your TA will test your code on a well-chosen pair of integers a & d.


;PART 2: The Sieve of Eratosthenes

;The Sieve of Eratosthenes is a recursive procedure used to find prime 
;numbers.  Let's model it in Scheme.

;We need to start with a list of integers from 2 up to n, so let's make
;that:

(define (integers n)
  (cdr (reverse (Integers n))))

(define (Integers n)
  (if (= 0 n) 
      '()
      (cons n (Integers (- n 1)))))

;So (integers 50) will give you (2 3 4 5 ... 50), all set and ready to
;sieve for primes.

;Now, to create the Sieve of Eratosthenes, we just need to cons the head
;of the list onto the list we get recursively KEEPing non-multiples of
;that head of the list while CHUCKing the multiples of the list. 
;Something like this:

;Simple launch:
(define (sieve n)
  (Sieve (integers n)))

;List-building procedure:
(define (Sieve list-of-ints)
  (if (null? list-of-ints)
      '()
      (cons "head" (Sieve "crossed-out stuff"))))


;Procedure to cull multiples of item from the list-of-ints
(define (cross-out prime list-of-ints)
  "Your definition goes here")

      
;(sieve 100) should be a list of the first 25 primes.  Give it a try!

;(sieve 80000) will take a little bit of time.  Ten seconds? 20?
;The Sieve of Eratosthenes is O(n^2).  Anything up around 100000 will be
;too slow to be useful.  So in PART 3 we'll check for primality of n
;more directly.

;Now use (sieve n) and some built-in function or other compute (pi n), 
;the number of primes not exceeding n.

(define (pi n)
  "Your one-line definition goes here")

;So  (pi 2) --> 1
;and (pi 100) --> 25

;Your TA will check (sieve 314) or so, and (pi 314)


;PART 3: prime?

;Let's check to see whether an integer n is prime, and let's do it in 
;two ways:

;First, if n is prime, what can you say about (sieve n) from PART 1?
;
;That should make (prime? n) very easy indeed:
;
;Write function/predicate "sieve-prime?" that does this.
;
;(define (sieve-prime? n)
;    (if (something about (sieve n))
;        #t
;        #f
;
;(sieve-prime? 21)  --> #f
;(sieve-prime? 103) --> #t
;
;The problem with this (sieve-prime? n) is that we MUST find all the 
;primes not exceeding n for it to work, and as we saw in PART 2 up 
;there, that can be a lot of work when n gets big.
;
;So let's write a version (prime? n) that doesn't do quite so much extra 
;work.  Let's simply check all (?!) the possible divisors of n, and if 
;none of them actually divide n, then we know p IS prime.  If we find a 
;divisor, then we know n is composite and NOT prime.

;We'll do something now that we may do quite a bit from here on out.
;Start with a simple "launch" program that will call the program that 
;does the real work.

;We want (prime? n) to start us off, but we need to kount our way up (or 
;down), and there's no argument there (in "prime?") for kounting.  So 
;the heavy-lifting program is going to need that extra parameter:

;Before you begin--and you will have complete freedom in this exercise--
;think about whether you want to kount up or kount down.  Both work 
;perfectly well.  Why have you made your choice?

;How high will you have to kount?  Where will you start your kount down?

;Is there a way you can save yourself some work?  Are there some 
;potential divisors you can spare yourself from having to test?

;HINT: We have always kounted in "1's", but you don't have to.
;Also HINT:  Your launch program can do more than just launch your "real"
;program.  it can do some initial checks / housekeeping if you let it.

;Still want to kount up/down?  Changed your mind at all?  A naive, 
;brutish approach is fine today (though the sieve is TOO naive for us),
;but see if you can add a dash of elegance to your approach.

(define (prime? n)
  (Prime? 2 n))

;(define (Prime? possible-divisor n)
;  (if (possible-divisor is too big/too small)
;      #t/#f (p IS prime) 
;      (if (possible-divisor IS really a divisor)
;          #f/#t (p is NOT prime)
;          (Prime? next-possible-divisor n))))


;The cond version looks like this:

;(define (Prime? possible-divisor n)
;  (cond [(possible-divisor is too big/too small) #t/#f (p IS prime)] 
;        [(possible-divisor IS really a divisor) #f/#t (p is NOT prime)]
;        [else (Prime? next-possible-divisor n)]))

;So you must do four (very easy) things to make this code work:
;0)  Make sure you start "possible-divisor" with the correct value when
;     (prime? n) launches (Prime possible-divisor n)
;1)  What does it mean for possible-divisor to be too big /too small?
;      Hint:  You don't have to check everything less than n.
;2)  Decide whether n prime means #t or #f
;3)  How do you know whether possible-divisor is REALLY a divisor
;      Hint:  Don't forget quotient/modulo/remainder, etc.
;4)  As we kount up/down, what is the next-possible-divisor?
;      So far, our recursions have usually been on shortening lists or 
;kounting down to zero.  
  
;Your TA will check your (prime? n) on a prime and a composite far too
;big for the Sieve to work before the semester ends.


;PART 4:  FACTORING 
;
;We want to finish today with program 'factor' that creates the list of 
;factors (including multiples) of a positive integer:

;(factor 126) --> (2 3 3 7)
;(factor 49)  --> (7 7)
;(factor 101) --> (101)
;(factor 72)  --> (2 2 2 3 3)
;(factor 64)  --> (2 2 2 2 2 2)

;Here are two suggestions, the harder one first.  (You need do just one.)

;One approach would be to use the sieve program.  You need only check
;potential divisors up to SquareRoot(n).  But be careful!  If n is prime 
;you need a way to catch that.  Also, you might lose the largest divisor 
;if you're not careful.  It'll work, but it has some tricks and traps.

;(define (factor n)
;   (Factor n (sieve n))) ;this launches Factor with n AND a list of primes.  Could we make do with a shorter list of primes?  Are you sure?
;
;(define (Factor number list-of-primes)
;  (if (  end if number is 1 or if list-of-primes is null )
;      '()  
;      (if (car list-of-primes) divides number)
;          (cons (car list-of-primes) recur on smaller number (n/p) 
;                                     but keep p in list....why?
;          recur on shorter list of primes
;
;Factor actually does something very interesting.  It recurs in TWO 
;different ways:  When it finds a factor, it recurs on a smaller value 
;of n, that is "n divided by the prime factor", so n gets smaller.  This 
;will allow us to find the same factor again if it appears multiple 
;times in a factorization.  We leave the list of primes alone.
;On the other hand, if the first prime in the list is NOT a factor, we 
;recur on a shortened list (cdr list-of-primes).  Now, we terminate 
;either when the number we are trying to factor is 1 OR when the list of 
;primes is empty.


;Perhaps a more straightforward approach is just to start k at two and 
;check to see whether k divides n.  
;If it does, cons it to the list recurring on n/k, that is, "factor" n/k)
;If it does not, throw it away and recur on a bigger k.
;
;Of course, that leaves the question...how/when do we end our recursion?
;(Remember, if n is prime, it will be the only entry in its list of prime
;factors:
;(factor 101) --> (101)

;That's a skeleton of one way to work it.  Feel free to do it another 
;way...

(define (factor n)
  "Your definition goes here.")
      
;Now, make sure 
;(factor 126) --> (2 3 3 7)
;(factor 49)  --> (7 7)
;(factor 101) --> (101)
;(factor 72)  --> (2 2 2 3 3)
;(factor 64)  --> (2 2 2 2 2 2)


;GOLDEN TICKET    The Chocolate Factor-y

;Mr. Wonka makes his premium chocolate from the best cacao beans--these
;are palindromic beans that look the same whether viewed frontways or 
;backways, slantways or slideways.  Here's today's shipment:

(define pal-dro-beans '(1111111 1113111 1117111 1131311 1133311 1137311 1171711 1173711 1177711 1311131 1313131 1317131 1331331 1333331 1337331 1371731 1373731 1377731 1711171 1713171 1717171 1731371 1733371 1737371 1771771 1773771 1777771 3111113 3113113 3117113 3131313 3133313 3137313 3171713 3173713 3177713 3311133 3313133 3317133 3331333 3333333 3337333 3371733 3373733 3377733 3711173 3713173 3717173 3731373 3733373 3737373 3771773 3773773 3777773 7111117 7113117 7117117 7131317 7133317 7137317 7171717 7173717 7177717 7311137 7313137 7317137 7331337 7333337 7337337 7371737 7373737 7377737 7711177 7713177 7717177 7731377 7733377 7737377 7771777 7773777 7777777))

;As always, Mr. Wonka wants to be better-than-best, and so it is your job
;to remove from these premium beans only the rarest ones for his lastest
;greatest chocolate confection: 7-Figure Theo-PRIME-ine Number Krunchies.

;It's expected that fewer than 20% of these premium pal-dro-beans will 
;qualify for PRIME status.

;HINT: If you've done EVERYTHING right today, this is a one-liner.
;Of course, it might be more fun to play with it a bit ....

;Here's last week's shipment if you're interested:
;(Do you expect a higher or lower percentage of prime beans?)

(define cool-beans    '(1111111 1113111 1117111 1119111 1131311 1133311 1137311 1139311 1171711 1173711 1177711 1179711 1191911 1193911 1197911 1199911 1311131 1313131 1317131 1319131 1331331 1333331 1337331 1339331 1371731 1373731 1377731 1379731 1391931 1393931 1397931 1399931 1711171 1713171 1717171 1719171 1731371 1733371 1737371 1739371 1771771 1773771 1777771 1779771 1791971 1793971 1797971 1799971 1911191 1913191 1917191 1919191 1931391 1933391 1937391 1939391 1971791 1973791 1977791 1979791 1991991 1993991 1997991 1999991 3111113 3113113 3117113 3119113 3131313 3133313 3137313 3139313 3171713 3173713 3177713 3179713 3191913 3193913 3197913 3199913 3311133 3313133 3317133 3319133 3331333 3333333 3337333 3339333 3371733 3373733 3377733 3379733 3391933 3393933 3397933 3399933 3711173 3713173 3717173 3719173 3731373 3733373 3737373 3739373 3771773 3773773 3777773 3779773 3791973 3793973 3797973 3799973 3911193 3913193 3917193 3919193 3931393 3933393 3937393 3939393 3971793 3973793 3977793 3979793 3991993 3993993 3997993 3999993 7111117 7113117 7117117 7119117 7131317 7133317 7137317 7139317 7171717 7173717 7177717 7179717 7191917 7193917 7197917 7199917 7311137 7313137 7317137 7319137 7331337 7333337 7337337 7339337 7371737 7373737 7377737 7379737 7391937 7393937 7397937 7399937 7711177 7713177 7717177 7719177 7731377 7733377 7737377 7739377 7771777 7773777 7777777 7779777 7791977 7793977 7797977 7799977 7911197 7913197 7917197 7919197 7931397 7933397 7937397 7939397 7971797 7973797 7977797 7979797 7991997 7993997 7997997 7999997 9111119 9113119 9117119 9119119 9131319 9133319 9137319 9139319 9171719 9173719 9177719 9179719 9191919 9193919 9197919 9199919 9311139 9313139 9317139 9319139 9331339 9333339 9337339 9339339 9371739 9373739 9377739 9379739 9391939 9393939 9397939 9399939 9711179 9713179 9717179 9719179 9731379 9733379 9737379 9739379 9771779 9773779 9777779 9779779 9791979 9793979 9797979 9799979 9911199 9913199 9917199 9919199 9931399 9933399 9937399 9939399 9971799 9973799 9977799 9979799 9991999 9993999 9997999 9999999))
